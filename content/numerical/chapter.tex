\chapter{Numerical}
\section{Newton's method}
	To compute $B = \frac{1}{A}$ modulo $x^m$: define $B_1 = \{inv(A[0])\}$ and $B_{2n} = B_n (2 - A \cdot B_n)$.


	To compute $B = \sqrt{A}$ modulo $x^m$: define $B_1 = \{\sqrt{A[0]}\}$ and $B_{2n} = \frac{B_n}{2} + \frac{A}{2B_n}$.


	To compute $B = \log (1 + xA)$ modulo $x^m$: $B = \int\frac{(1 + xA)'}{1 + xA}$.

	If $T$ is EGF for some objects then $C = -\log (1 - T) = \sum_{k = 1}^{+\infty} \frac{T^k}{k}$ is EGF for cycles of them.


	To compute $B = e^{xA}$ modulo $x^m$: define $B_1 = \{1\}$ and $B_{2n} = B_n(1 + A - \log B_n)$.

	If $T$ is EGF for some objects then $F = e^T = \sum_{k = 0}^{\infty} \frac{T^k}{k!}$ is EGF for their unordered combinations.

	In general case you have equation $P(B, x) = 0$. (f.e. $\log B - A(x) = 0$).

	The transition is $B_{2n - \alpha} = B_n - \frac{P(B, x)}{P_B'(B, x)}$. (if $P_B'(B, x)$ is divisible by $x^\alpha$).
\section{Additional modulos for FFT}
\begin{center}
	\begin{tabular}{ c | c | c }
		Modulo & Other form & Roots \\
		$998244353$ & $(119 << 23) + 1$ & $3, 62$ \\
		$167772161$ & $(5 << 25) + 1$ & $3, 62$ \\
		$469762049$ & $(7 << 26) + 1$ & $3, 62$ \\
		$1004535809$ & $(479 << 21) + 1$ & $3, 62$ \\
		$1012924417$ & $(483 << 21) + 1$ & $62$ \\

	\end{tabular}
\end{center}

\kactlimport{fft.cpp}{FFT}
\kactlimport{mult.cpp}{Middle product}
\kactlimport{inv.cpp}{Polynomial division}
\kactlimport{berlekamp_massey.cpp}{Berlekamp-Massey}
\section{Linear recurrence}
Let $A$ be generating function for our recurrence, $C$ be its characteristic polynomial and $k = |C|$.

Let $D = C \cdot A$. Then $D \text{ mod } x^k = D$
$$A = \frac{(A \text{ mod } x^k) C \text{ mod } x^k}{C} = \frac{A_0C \text{ mod } x^k}{C}$$
$$[x^n]\frac{P(x)}{Q(x)} = [x^n]\frac{P(x)Q(-x)}{Q(x)Q(-x)}$$

\section{Xor-And-Or Convolutions}
To compute
$$c_i = \sum_{j, k : j | k = i} a_j \cdot b_k$$
we transform (a) and (b) into their subset sums, take the elementwise product, and then apply the inverse transform.

For
$$c_i = \sum_{j, k : j \& k = i} a_j \cdot b_k$$
we transform (a) and (b) into their superset sums and do the same.

To compute
$$c_i = \sum_{j, k : j \oplus k = i} a_j \cdot b_k$$
we applay Walsh-Hadamard transform, take the elementwise product, and then apply the inverse transform.

\kactlimport{walsh-hadamard.cpp}{Walsh-Hadamard}